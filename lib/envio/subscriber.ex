defmodule Envio.Subscriber do
  @moduledoc """
  Subscriber helper scaffold.

  To easy register the `pub_sub` consumer in `Envio.Registry`, one might
  use this helper to scaffold the registering/unregistering code.
  It turns the module into the `GenServer` and provides the handy wrapper
  for the respective `handle_info/2`. One might override
  `handle_envio

  The typical usage would be:

  ```elixir
  defmodule PubSubscriber do
    use Envio.Subscriber, channels: [{PubPublisher, :foo}]

    def handle_envio(message, state) do
      with {:noreply, state} <- super(message, state) do
        IO.inspect({message, state}, label: "Received message")
        {:noreply, state}
      end
    end
  end
  ```

  If channels are not specified as a parameter in call to `use Envio.Subscriber`,
  this module might subscribe to any publisher later with `subscribe/1`:

  ```elixir
  PubSubscriber.subscribe(%Envio.Channel{source: PubPublisher, name: :foo})
  ```
  """

  @doc """
  The callback to subscribe stuff to `Envio`.
  """
  @callback handle_envio(binary() | atom(), map()) ::
              {:noreply, new_state}
              | {:noreply, new_state, timeout() | :hibernate | {:continue, term()}}
              | {:stop, reason :: term(), new_state}
            when new_state: term()

  defmacro __using__(opts \\ []) do
    quote bind_quoted: [opts: opts] do
      require Logger
      use GenServer

      @behaviour Envio.Subscriber

      @namespace Macro.underscore(__MODULE__)
      @fq_joiner "."
      @max_messages Application.get_env(:envio, :subscriber_queue_size, 10)

      @impl true
      @spec handle_envio(message :: :timeout | term(), state :: State.t()) ::
              {:noreply, new_state}
              | {:noreply, new_state, timeout() | :hibernate | {:continue, term()}}
              | {:stop, reason :: term(), new_state}
            when new_state: State.t()
      @doc """
      Default implementation of the callback invoked when the message is received.
      """
      def handle_envio(message, state) do
        messages =
          case Enum.count(state.messages) do
            n when n > @max_messages ->
              with [_ | tail] <- :lists.reverse(state.messages),
                   do: :lists.reverse([message | tail])

            _ ->
              [message | state.messages]
          end

        {:noreply, %Envio.State{state | messages: messages}}
      end

      @spec subscribe(channel :: %Envio.Channel{} | [%Envio.Channel{}]) :: {:ok, %Envio.State{}}
      @doc """
      Subscribes to the channel(s) given in a runtime.
      """
      def subscribe(%Envio.Channel{} = channel), do: subscribe([channel])

      def subscribe([_ | _] = channels),
        do: GenServer.call(__MODULE__, {:subscribe, channels})

      defoverridable handle_envio: 2

      ##########################################################################

      @doc """
      Helper generated by the `Envio.Subscriber` scaffold. This `pub_sub`
      `GenServer` might be started by invoking `#{__MODULE__}.start_link`.
      """
      @spec start_link(list()) ::
              {:ok, pid()} | :ignore | {:error, {:already_started, pid()} | term()}
      def start_link(opts \\ []),
        do: GenServer.start_link(__MODULE__, %Envio.State{options: opts}, name: __MODULE__)

      @channels opts
                |> Keyword.get(:channels, [])
                |> Enum.map(fn {source, channel} ->
                  %Envio.Channel{source: source, name: channel}
                end)

      @impl true
      @doc false
      def init(%Envio.State{} = state), do: do_subscribe(@channels, state)

      @impl true
      @doc false
      @spec handle_call(
              {:subscribe, channels :: [%Envio.Channel{}]},
              pid(),
              state :: %Envio.State{}
            ) :: {:reply, %MapSet{}, %Envio.State{}}
      def handle_call({:subscribe, [_ | _] = channels}, _from, %Envio.State{} = state) do
        with {:ok, %Envio.State{subscriptions: subscriptions}} <- do_subscribe(channels, state) do
          {:reply, subscriptions[__MODULE__], state}
        else
          error -> {:reply, {:error, error}, state}
        end
      end

      @impl true
      @doc false
      def handle_info({:envio, {channel, message}}, state),
        do: handle_envio(message, state)

      ##########################################################################

      @spec do_subscribe(channels :: [%Envio.Channel{}], state :: %Envio.State{}) ::
              {:ok, %Envio.State{}}
      defp do_subscribe(channels, %Envio.State{} = state) do
        channels =
          channels
          |> MapSet.new()
          |> Enum.map(&{:pub_sub, &1})

        Enum.each(channels, fn
          {:pub_sub, channel} ->
            Registry.register(
              Envio.Registry,
              Envio.Channel.fq_name(channel),
              {:pub_sub, __MODULE__}
            )

          # TODO Maybe support :dispatch here as well?
          {kind, channel} ->
            Logger.warn("Wrong type #{kind} for channel #{inspect(channel)}. Must be :pub_sub.")
        end)

        channels = Envio.Channels.register(__MODULE__, channels)
        {:ok, %Envio.State{state | subscriptions: %{__MODULE__ => channels}}}
      end
    end
  end
end
